<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Family Tree - SVG & Vanilla JS</title>
    <script src="data.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; }
        svg { border: 1px solid #ccc; }
        .male { fill: lightblue; stroke: black; stroke-width: 1px; }
        .female { fill: lightpink; stroke: black; stroke-width: 1px; }
        .link { stroke: black; stroke-width: 1.5px; }
        .textbox { fill: white; stroke: black; stroke-width: 1px; }
        text { font-size: 10px; text-anchor: middle; }
        .tab { display: inline-block; padding: 10px; cursor: pointer; background: #f0f0f0; margin: 5px; }
        .tab.active { background: #d0d0d0; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        a { fill: blue; text-decoration: underline; }
    </style>
</head>
<body>
    <h2>Family Tree</h2>
    <div id="tabs"></div>
    <div id="tab-contents"></div>
    
    <script>
        function buildTree(data, svgId, minGen, maxGen) {
            const svg = document.getElementById(svgId);
            const filteredData = data.filter(p => p.Generation >= minGen && p.Generation <= maxGen);
            const width = 2500; // Wider for more spacing
            const height = 1200; // Taller for textboxes and spacing
            const genHeight = height / (maxGen - minGen + 1);

            const nodesByGen = Array(maxGen - minGen + 1).fill().map(() => []);
            filteredData.forEach(person => {
                nodesByGen[person.Generation - minGen].push(person);
            });

            const nodes = [];
            let totalWidthUsed = 0;

            nodesByGen.forEach((gen, genIndex) => {
                const y = genIndex * genHeight + genHeight / 2;
                const coupleWidth = 300; // Increased for shape + textbox + padding
                const coupleSpacing = 200; // Increased for more gap between couples
                let currentX = 50;
                const genMales = gen.filter(p => p.Sex === "M" && !p.BranchCode.includes("w"));
                genMales.forEach(male => {
                    nodes.push({ ...male, x: currentX, y });
                    const w1 = gen.find(p => p.BranchCode === `${male.BranchCode}w1`);
                    if (w1) nodes.push({ ...w1, x: currentX + 70, y }); // Adjusted spacing within couple
                    const w2 = gen.find(p => p.BranchCode === `${male.BranchCode}w2`);
                    if (w2) nodes.push({ ...w2, x: currentX + 140, y });
                    currentX += coupleWidth + coupleSpacing;
                });
                const genExtras = gen.filter(p => p.Sex === "F" && !p.BranchCode.includes("w"));
                genExtras.forEach((person, i) => {
                    nodes.push({ ...person, x: currentX + i * (coupleWidth + coupleSpacing), y });
                    currentX += coupleWidth + coupleSpacing;
                });
                totalWidthUsed = Math.max(totalWidthUsed, currentX - coupleSpacing); // Track widest generation
            });

            // Center the tree
            const xOffset = (width - totalWidthUsed) / 2;
            nodes.forEach(node => node.x += xOffset);

            nodes.forEach(node => {
                if (node.Goc) {
                    const fatherCode = node.Goc.replace("#", "");
                    const mother = nodes.find(n => n.BranchCode === `${fatherCode}w1`);
                    if (mother) {
                        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line.setAttribute("x1", mother.x);
                        line.setAttribute("y1", mother.y + 20);
                        line.setAttribute("x2", node.x);
                        line.setAttribute("y2", node.y - 30);
                        line.setAttribute("class", "link");
                        svg.appendChild(line);
                    }
                }
                if (node.Sex === "M" && !node.BranchCode.includes("w")) {
                    const spouse1 = nodes.find(s => s.BranchCode === `${node.BranchCode}w1`);
                    const spouse2 = nodes.find(s => s.BranchCode === `${node.BranchCode}w2`);
                    if (spouse1) {
                        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line.setAttribute("x1", node.x + 20);
                        line.setAttribute("x2", spouse1.x - 20);
                        line.setAttribute("y1", node.y);
                        line.setAttribute("y2", spouse1.y);
                        line.setAttribute("class", "link");
                        svg.appendChild(line);
                    }
                    if (spouse2) {
                        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line.setAttribute("x1", spouse1 ? spouse1.x + 20 : node.x + 20);
                        line.setAttribute("x2", spouse2.x - 20);
                        line.setAttribute("y1", spouse2.y);
                        line.setAttribute("y2", spouse2.y);
                        line.setAttribute("class", "link");
                        svg.appendChild(line);
                    }
                }
            });

            nodes.forEach(node => {
                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                g.setAttribute("transform", `translate(${node.x},${node.y})`);

                const shape = document.createElementNS("http://www.w3.org/2000/svg", node.Sex === "M" ? "rect" : "circle");
                shape.setAttribute("class", node.Sex === "M" ? "male" : "female");
                if (node.Sex === "M") {
                    shape.setAttribute("x", -20);
                    shape.setAttribute("y", -20);
                    shape.setAttribute("width", 40);
                    shape.setAttribute("height", 40);
                } else {
                    shape.setAttribute("r", 20);
                }
                g.appendChild(shape);

                const textbox = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                textbox.setAttribute("class", "textbox");
                textbox.setAttribute("x", -75);
                textbox.setAttribute("y", 30); // Further below shape for more space
                textbox.setAttribute("width", 150);
                textbox.setAttribute("height", 90); // Taller for spacing
                g.appendChild(textbox);

                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                const gocLink = node.Goc ? `<tspan x="0" dy="11"><a xlink:href="#node-${findGreatGreatGrandma(data, node.BranchCode)}" target="_self">Goc: ${node.Goc}</a></tspan>` : '';
                text.innerHTML = `${node["Real Name"]}<tspan x="0" dy="11">ID: ${node.ID}</tspan><tspan x="0" dy="11">Branch: ${node.BranchCode}</tspan><tspan x="0" dy="11">Born: ${node.Birthyear}</tspan><tspan x="0" dy="11">Died: ${node["Death Date"]}</tspan><tspan x="0" dy="11">Lunar: ${node["Death Date (Vietnamese Lunar)"]}</tspan><tspan x="0" dy="11">Addr: ${node.Address}</tspan>${gocLink}`;
                text.setAttribute("x", 0);
                text.setAttribute("y", 35); // Adjusted for taller textbox
                g.appendChild(text);

                g.setAttribute("id", `node-${node.BranchCode}`);
                svg.appendChild(g);
            });
        }

        function findGreatGreatGrandma(data, branchCode) {
            let current = data.find(p => p.BranchCode === branchCode);
            let steps = 0;
            while (current && current.Goc && steps < 4) {
                const fatherCode = current.Goc.replace("#", "");
                current = data.find(p => p.BranchCode === fatherCode);
                steps++;
            }
            if (steps >= 2 && current) {
                const motherCode = `${current.BranchCode}w1`;
                return motherCode;
            }
            return "man1w1";
        }

        function createTabs() {
            const tabsDiv = document.getElementById("tabs");
            const contentsDiv = document.getElementById("tab-contents");
            
            const tab1 = document.createElement("div");
            tab1.className = "tab active";
            tab1.textContent = "Gen 1-3";
            tab1.onclick = () => switchTab("tab1");
            tabsDiv.appendChild(tab1);

            const content1 = document.createElement("div");
            content1.id = "tab1";
            content1.className = "tab-content active";
            const svg1 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg1.setAttribute("id", "svg1");
            svg1.setAttribute("width", "2500");
            svg1.setAttribute("height", "1200");
            content1.appendChild(svg1);
            contentsDiv.appendChild(content1);
            buildTree(datajs, "svg1", 1, 3);

            const gen3Males = datajs.filter(p => p.Generation === 3 && p.Sex === "M" && !p.BranchCode.includes("w"));
            gen3Males.forEach((male, index) => {
                const tabId = `tab${index + 2}`;
                const tab = document.createElement("div");
                tab.className = "tab";
                tab.textContent = `${male["Real Name"]} (${male.BranchCode}) Gen 4-7`;
                tab.onclick = () => switchTab(tabId);
                tabsDiv.appendChild(tab);

                const content = document.createElement("div");
                content.id = tabId;
                content.className = "tab-content";
                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svg.setAttribute("id", `svg${index + 2}`);
                svg.setAttribute("width", "2500");
                svg.setAttribute("height", "1200");
                content.appendChild(svg);
                contentsDiv.appendChild(content);

                const descendants = getDescendants(datajs, male.BranchCode, 4, 7);
                buildTree(descendants, `svg${index + 2}`, 4, 7);
            });
        }

        function getDescendants(data, branchCode, minGen, maxGen) {
            const descendants = [];
            function addDescendant(code) {
                const person = data.find(p => p.BranchCode === code);
                if (person && person.Generation >= minGen && person.Generation <= maxGen) {
                    descendants.push(person);
                    data.filter(p => p.Goc === `#${code}`).forEach(child => addDescendant(child.BranchCode));
                    const w1 = data.find(p => p.BranchCode === `${code}w1`);
                    if (w1) descendants.push(w1);
                    const w2 = data.find(p => p.BranchCode === `${code}w2`);
                    if (w2) descendants.push(w2);
                }
            }
            addDescendant(branchCode);
            return descendants;
        }

        function switchTab(activeId) {
            document.querySelectorAll(".tab").forEach(tab => tab.classList.remove("active"));
            document.querySelectorAll(".tab-content").forEach(content => content.classList.remove("active"));
            document.getElementById(activeId).classList.add("active");
            document.querySelector(`.tab[onclick="switchTab('${activeId}')"]`).classList.add("active");
        }

        window.onload = () => {
            if (typeof datajs === "undefined") {
                console.error("Error: datajs is not defined. Check if data.js is loaded correctly.");
                document.body.innerHTML += "<p>Error: Could not load family tree data.</p>";
            } else {
                createTabs();
            }
        };
    </script>
</body>
</html>
